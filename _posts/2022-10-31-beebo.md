---
layout: post
title:  "Notes about the Polyeffects Beebo"
date:   2022-10-31 20:10:00 +0100
---

The [Polyeffects Beebo](https://www.polyeffects.com/) is many things:
- a multi effects box for synthesizers
- an amp simulation and effects pedal for guitar and bass
- a polyphonic synthesizer
- a modular synthesizer in a box
- a loop station

One thing it is not:
- well documented

![The Polyeffects Beebo](/bilder/beebo.jpg)

That's why I write down here what I found out about its 149 modules. May it be of use for future me and for other Beebo/Hector users. However,
note that I am not at all competent in what I do here. I won't reveal the inner workings of the ORG Reverb module for the simple reason that
I have no more than the most basic knowledge about effect units. Also, I can't say much about the guitar and bass amp and cab modules, because I have
neither guitar nor bass.

In my descriptions, I will also usually omit knobs or inputs which are super obvious or which can be easily googled, e.g. the parameters of common effect units.

This is also not meant to be an introduction to the Beebo. If you are new to this device, read the official manual first.

Anyway, let's start. My notes are valid for firmware version 327.
 
# General remarks
There are 4 different types of signals which can be routed between input, output and the individual modules like cables beween physical units:
- Audio: a single (i.e. mono) audio stream
- CV: control signals between modules
- Midi: a stream of Midi messages
- Tempo: tempo messages to synchronize modules

## More on CV signals
On physical modular synthesizers, CV (short for _control voltage_) signals are voltages in a defined range (e.g. -5V – +5V or 0V – 10V) and the
modules can use these voltages to communicate with each other. In the Beebo, being fully digital, these voltages are of course only virtual, but I'm
still going to use the unit symbol _V_.

The Beebo usually uses virtual voltages in the range -5V – +5V, but other values are possible.

The CV signals serve a lot of different purposes: they can activate a module, set a parameter of a module, define the amplitude of a sound over
time (i.e. the envelope) and other things. So it makes sense to further divide the CV signals into subtypes. I'm going to prefix the subtype names
with _Cv_, to make it clear if I'm talking about e.g. triggers in a general sense or about a CV signal which is acting as a trigger.

- CvTrigger
    (Bild)
    A signal at level 0V most of the time with a very short spike to 5V and back. It is used to, well, trigger some behavior in a module. Modules which
    receive a _CvTrigger_ (at least the ones I tested) actually seem to to react to all CV signals which get higher than 2V.

- CvGate
    (Bild)
    A signal at level 0V with a sudden flank up to 5V and back to 0V after some time. Used to activate and then deactivate some behavior in a module. As
    with _CvTriggers_, on a receiving module, all signals which cross the boundary of 2V seem to work as _CvGate_.

- CvEnvelope
    (Bild)

- CvPitch
    (Bild)
    Represents a constant or changing pitch over time.
    A signal at level 0V usually represents C4 (the middle C), 1V is C5, 2V is C6, -1V is C3, 0.08333V is C♯4 etc.

- CvSetting
    Is used to set settings of modules which may vary over time, also known as modulation.

    Most of the modules have sliders and knobs to configure them. Some of these settings can be controlled not only by manually slide the sliders but also
    using a signal. It seems that the range for the signal is always 0V to 5V (for monomodal settings) or -5V to 5V (for bimodal settings), no matter
    which range is displayed at the slider. For example: if a slider has a displayed range from 0 to 1 (the most frequent case), feed a value of 4V into
    the module to set it to a value of 0.8. That's why there is sometimes a factor of 5 which crops up in my descriptions of the modules.

    Keep in mind that when a slider is controlled by a _CvSettings_ input, the displayed value of the slider is ignored. It is also not visible which
    slider is currently externally controlled.


This is my own made-up distinction of CV subtypes. It is only a logical distinction, not a technical one. Nobody stops you from feeding the triggers
coming from the foot pedal module into the cv/oct input of the Macro Osc module, even though it doesn't make any sense. In my description of the
modules, I'm going to state which type of CV signal is meant to be used, but feel free to disregard it. Maybe you come up with some cool stuff.

## A word about Midi
If you have trouble connecting other gear to the Beebo via Midi, keep in mind that there are two kinds of frequently used Midi TRS connectors, which
are visually indistinguishable. They are, originally enough, called type A and type B. Different batches of the Beebo require different types of these
connectors.
According to the [FAQ](https://www.polyeffects.com/faqs), the following types are used (you can find the serial number on a sticker on the back of the Beebo):
- Pink case with serial number ≤ 474 or blue case with serial number ≤ 337: type B for in and out
- Pink case with serial number 475–876 or blue case with serial number 338–936: type A for input, type B for output
- Pink case with serial number ≥ 877 or blue case with serial number ≥ 937: type A for in and out

## Global settings
In the global settings menu, there is a setting **Midi channel**. I don't know what it does, because AFAICS all modules either have individual
settings for their input or output channel, or they listen to all channels, or their output channel depends on the input.

If **D is Tuner** is switched on, the foot switch D (that is, A and B at the same time) immediately switches to a patch containing the Guitar Tuner module.

# The modules
## Audio sources
These modules produce audio triggered by _CvTriggers_ or _CvGates_.

### Macro OSC
**Warning**: the audio output of this module is rather loud when using headphones. Consider routing the audio through a [VCA module](#vca) with gain
around 0.5.

A monophonic instrument and drum synthesizer with 16 different synthesis engines, or 32 if you want, because each one has two variants, which
emit their audios on the **Out** and **Aux** outputs, respectively.

The first 11 (melody-like) engines are triggered in a different way than the last 5 (which are more suitable for drums):

For the first 11 engines, there are multiple ways to trigger a sound:
- feed a _CvEnvelope_ (or a _CvGate_ (which is only a special case of an envelope)) into **Input Level**
- feed a _CvTrigger_ into **Input Trigger** while there is no connection to **Input Level**: a sound is played with an AD envelope (which really looks
  like a reverse sawtooth, that is, A=0). This envelope can control no less than 5 values: volume, cutoff of an internal LPF, frequency, morph and
  timbre. The sliders **Frequency Mod**, **Morph Mod** and **Timbre Mod** control the amount of that modulation. **LPG Color** controls the amount of 
  volume and filter modulation: left means only the filter, right means only volume. **LPG Decay** controls the decay of the envelope.
- if there are both an _CvEnvelope_ at **Input Level** and a _CvTrigger_ at **Input Trigger**, the sound caused by the former is temporarily overlaid
  with the latter. But in this case, the AD envelope doesn't modulate frequency, morph and timbre.

For the last 5 engines, it’s a bit simpler:
- feed a _CvTrigger_ into **Input Trigger* to trigger the drum sound. The **LPG Color** and **LPG Decay** sliders have no effect, because the engines
  all have a decay slider in the tab with their individual settings.
- insert a _CvTrigger_ into **Input Trigger** and a _CvGate_ into **Input Level** at the same time to produce an acceted drum sound
- insert a _CvEnvelope_ into **Input Level** while there is no connection to **Input Trigger**. This produces a sustained drum sound, which 
  itself is not exactly useful, but you can use that to have full control over the envelope, e.g. by connecting one of the [envelope modules](#envelope-sources) to the **Level CV** input.

To control the pitch of the sound, use either a _CvPitch_ with **Input V/Oct** or **Input Frequency**. For the latter, you have to set the slider **Frequency Mod** to
a value ≠ 0. Or use both, e.g. **Input V/Oct** to set the note and and LFO to **Input Frequency** to produce a vibrato.

The values of the sliders in the **Modulation** submenu are multiplied with the corresponding input signals. So, to modulate e.g. the timbre value,
set **Setting Timbre Mod** to ≠ 0 and feed an LFO into **Input Timbre Cv**.

In the **Tone** submenu, the sound can be adjusted. The 3 sliders behave different for each of the synth engines. **Timbre** usually
changes the sound from dark and dirty to bright and clean. **Harmonics** usually introduces dissonances.

The 16 synth engines are are relatively well documented in the [manual of the Plaits module](https://pichenettes.github.io/mutable-instruments-documentation/modules/plaits/manual/).
Here they are, as far as I understand them:
- Wavetable: 4×8×8 wave forms which can be passed through either smootly (that is, with interpolation) or 


## Gate or trigger sources
### Foot Switch A to E
Foot switch D is triggered if A and B are pressed at the same time. (If D is not assigned, both A and B are triggered in this case.)
E is the same with B and C.

Outputs of this module are
- a _CvGate_ with definable levels for the closed and the open phases. Depending on the **Is Latching** setting, the gate is open as long as the
  foot switch is pressed, or it switches between the two levels with each press.
- a tempo, either the configured one or the one determined by repeatedly pressing the foot switch. Can go from 35 to 350 BPM.

If you want to switch a complete module on and off using a foot switch, you don't need a foot switch module. Simply tap and hold a module and press the
desired foot switch.

### Onset Detect
Produces a _CvGate_ when there is a sudden amplitude raise in the audio input, e.g. a played note.

This module is not simply triggered when the input audio exceeds a certain threshold. Instead, **Onset Threshold** refers to the attack time of the
input audio: the higher the value, the faster the attack needs to be to trigger this module. At the lowest value, the attack still needs to be faster
than ~300ms.

### Cv to Trigger
Produces a _CvTrigger_, when the (arbitrary) CV input exceeds 0.4V. The input must fall to a lower level than that before a trigger can be produced
again.

### Drum patterns
Produces three periodic _CvTriggers_, which are meant to trigger a bass drum, a snare and a hihat, respectively. Together, they result in a
most of the time well-sounding drum pattern.

Additionally, there are three outputs which send out _CvTriggers_ if the corresponding drum beat may be accentuated.

The sliders _Bass Drum Density_, _Snare Density_ and _Hihat Density_ control **how often** the respective sound appears from _not at all_ to _on every beat_.

The sliders _Map X_ and _Map Y_ control **when** the three sounds appear. The pattern is deterministic, but not really predictable. Slowly changing
the X and Y values produces smooth transitions between patterns.

The _Chaos_ slider controls the amout of random variation of the _Density_ controls.

A _CvTrigger_ in the **Reset** input resets the pattern, so that it starts on the first beat again.

### Euclidean
The output is up to 4 tracks of _CvTriggers_ which can be used to create a drum pattern.

Each of the 4 tracks has an adjustable number (0–32) of steps. Of these, an adjustable number is _active_, all others are _passive_. Every time a
trigger goes into this module, each track jumps to its next step. If this next step is active, a _CvTrigger_ is emitted (to generate a drum sound.)

You can't precisely configure which steps of a track are active. All you can configure is the number of active steps and an offset. Starting from the
step set by offset, the active steps are evenly (as far as possible) distributed on the track.

If a track arrives on its first step again, a trigger on the corresponding **Is The One** output is emitted, no matter if the first step is active or not.

Use cases:
- if the lengths of the tracks are different (especially if they are coprime), interesting polyrhythms may emerge
- this pattern on the other hand produces a simple house beat: (Bild)

### Chaos controler
Outputs random, but controlled gates plus voltage levels for each gate.
It is based on [Marbles by Mutable Instruments](https://pichenettes.github.io/mutable-instruments-documentation/modules/marbles/manual/).

The “main” outputs are **T2 Output**, which emits a stream of _CvGates_, and **X2 Output**, which emits a voltage which is constant while the gate in
**T2** is open.
The outputs **T1 Output**/**X1 Output** and **T3 Output**/**X3 Output** work similar. Their appearances and values are somehow dependend of **T2**/**X2**.
The output **Y Output** is an additional random CV signal, which is independent (except for its tempo) of the **T** and **X** outputs.

In the page **Gate generator**, you control **T1** to **T3**, that is, _when_ the gates appear and their pulse width:
The gates of **T2** always have a 50% pulse width and go out evenly with the tempo set by the slider **T clock BPM** and its multiplier above.
Alternatively, new gates can be triggered by a _CvTrigger_ into **Input T clock trigger**. In this case, the slider **T clock BPM** has a different
functionality and acts as a random multiplier: values > 120 BPM will sometimes cause 2 or 3 gates per step, values < 120 BPM will cause a gate every 2
or 3 steps.

The slider **Jitter** adds randomness to the times of the gates. Also, it seems to randomly modify the pulse widths of **T1** and **T3**.

But generally, **T1** and **T3** are always very narrow pulses. Their times depend on the **Bias** slider and the configured mode:
- **Coin toss**: with each gate in **T2**, one gate comes out of either **T1** or **T3**, but not both. The heigher **Bias** is, the more likely it is
  that **T3** is the winner.
- **Random ratio**: when **Bias** is 0.5, all gates come out of **T1**, **T2** and **T3** at the same time. If it is less than 0.5, the gates of
  **T3** sometimes come out only every 2, 3, 4 or 8 steps of **T2**. If it is higher, **T3** may emit 2, 3, 4 or 8 gates with each step of **T2**.
  **T1** works vice versa.
- **Percussive triggers**: the gates of **T1** and **T3** come out in such a way that they form a drum pattern with kick and snare, respectively.
  **T2** could trigger hi-hats. A **Bias** value of 0.5 makes a regular boom-chuck pattern, other values cause more kick or snare triggers (but in a
  random way).

The page **X voltage** controls the levels which come out of **X1** to **X3**.

The 3 buttons under “Output voltage range” set the range of the voltages to 0–2V, 0–5V or -5–5V.

The slider **X spread** sets the probability distribution of the values from infinitesimally narrow bell curve (at 0.0) to bell curve to uniform
distribution (at ~0.7) to bathub shaped distribution.
The slider **X distribution bias** sets the position of the distribution curve in the range.

The slider under **Smoothness** controls how the X values are changed: at the center position, a new value is emitted with each step of **T2**. Left of
the center, the values glide smoothly between their values. Right of the center causes hard transitions, but the values are quanzited so that they, when
interpreted as _CvPitch_, belong to the scale set in the page **Steps quantizer**. The further right, the less different X values there will be.

The outputs **X1**, **X2** and **X3** work independently of another.
The 3 buttons under **Output controls** introduce even more diversity between these 3 outputs:
- the button in the middle makes it so that only **X2** follows the settings of 3 sliders in this page, while **X1** and **X3** will behave as if the 3 sliders are mirrored.
- the right button makes **X3** follow the settings and **X1** the mirrored settings. **X2** takes the middle positions of the 3 sliders. I think the
  icons of the middle and the right buttons should be swapped.
- the left button makes all outputs follow the sliders

As if that wasn't enough randomization, the whole behaviour of the **X**es is different if the slider **External control** is switched on. In this
case,**X2** take the value which is present at the **X spread** input at the time the gate starts. The slider **X spread** moves these values
(that is, adds a value) and **X bias** changes the value range (that is, multiplies it with a factor). This is a bit odd, it should be the other way
around. **X1** and **X3** have the same values as **X2** most of the time, but every now and then keep their values for several steps. That is, when
there is not input into **X clock**. If there is, other things happen which I don't understand.

In the section **Deja vu**, you can add some order to the chaos by making the patterns of the **T** and **X** outputs (partly) repeat.
With the two buttons **t** and **X**, you can set if you want to have repetitions in the **T**s or **X**es or both.
The slider **Deja vu length** controls the length of a repeated pattern from 1 step of **T2** to 2 steps (at ~0.2) to 8 (around ~0.8) to 16 (at 1.0).
The slider **Deja vu probability** (or **Deja vu Input**) controls how identical the repetitions will be: at 0.5, the pattern is repeated unchanged. The the further left,
the more random changes are applied. At values > 0.5, only values from within the remembered patterns are used, and the further right, the more
randomly it will jump inside the pattern buffer.

The page **Y voltage** controls the **Y** output. **Rate** is the tempo which goes from the rate of **T2** to the rate of **T2** divided by 64.
**Spread** sets the rage of **Y** values and goes from 0 to -5–5V. The icons of the **Bias** slider have the wrong order.

## Envelope sources
Modules which produce _CvEnvelopes_, triggered by _CvTriggers_, _CvGates_ or Audio.

### AD Envelope
A _CvTrigger_ on either input produces on the output a curve which looks like a triangle: linear rise from 0V to 5V for the time set with **Attack Time**, followed by a linear drop back to 0V for the time set with **Decay Time**.

The two inputs **Gate** and **Trigger** seem to behave identically, if I'm not mistaking.

If the input is a _CvGate_, it gets more complicated:
- first a logarithmic raise to 5V (logarithmic means a steep initial curve which gets flatter and flatter so that 5V are theoretically never reached)
- when the gate closes, the attack(!) phase starts by going linearly from the current value up to the final value of 5V in the time set under **Attack Time**
- afterwards, the decay phase starts by going down to 0V as above

### AD Env Level
Similar to [AD Envelope](#ad-envelope), this produces an envelope which may look like a triangle, but instead of going 0V → 5V → 0V, the three levels can be configured.

The two inputs **Gate** and **Trigger** seem to behave identically, if I'm not mistaking.

If the input is a _CvTrigger_, the output voltage jumps to **Initial Level**·5V, then rises (or drops) linearly to **Attack to Level**·5V in **Attack Time** seconds, then drops (or rises) to **Decay to Level**·5V in **Decay Time** seconds.

If the input is a _CvGate_, the output stays at **Initial Level**·5V as long as the gate is open, before rising and dropping.

**Input Reset Level** takes a _CvTrigger_ and makes the output jump to **Initial Level**·5V. At least if the envelope is in its “resting phase”. If this input is triggered while the envelope is in its rising or dropping phase, weird things happen. Not sure if this is a bug or intentional.

### ADSR
Produces your ordinary ADSR envelope out of a _CvGate_.

The control **Trigger Threshold** adjusts how high the input CV must be to count as an open gate.

### DAHDSR
Like [ADSR](#adsr), but with an additional delay phase (a certain time from the gate start until the attack phase starts) and an additional hold phase
(a certain time between the attack and the decay phases).

### Env Follower
Produces an ASD curve (looks like a trapezoid), but not triggered by a CV event, but whenever the input audio level exceeds a threshold.

If **Invert** is activated, the output is 5V - (the normal value), or in other words, the output looks like a bathtub.

### Looping Envelope
Can produce either an AD envelope, an AR envelope or function as an LFO. Can do more crazy transitions than linear ones. Can oszillate in audible
frequencies.

This is a clone of the [Tides](https://pichenettes.github.io/mutable-instruments-documentation/modules/tides_2018/) module by Mutable Instruments.

The mode is set under _Output_ → _Ramp mode_.

Under _Output_ → _Frequency rate_ you can set the frequency (in LFO mode) or the general A and D/R rates.

The shape of the ramps up and down are set in the _Shape_ submenu. The icons are self-explanatory, except that the icons at the _Slope_ slider are
mixed up. If the _Smoothness_ slider has a value right from the center, bumps and kinks are added to the curve. However, if _Output_ → _Frequency Range_
is _Audible tones_, the actual shape is different and more suited to curves in the audio range. See the Tides manual for the details.

The input **Trigger** wants a _CvTrigger_ if in AD or LFO mode and a _CvGate_ if in AR mode. In LFO mode, the input trigger makes the LFO start again
with an upwards slide.

The controls under **Mod** are multiplied with their respective inputs.

The frequency can be set from outside using the **Frequency** or **V per Oct** input, or with a periodic signal (e.g. a series of _CvTriggers_) at the
**Clock** input. In the latter case, the **Frequency** setting is relative to the tempo controlled by the clock.

As for the outputs, there are four of them, and their meaning depends on _Output_ → _Output mode_:
- _Different shapes_: ouput 1 is the “normal” output which is shaped like configured, while the ouputs 2 to 4 are something different. Consult the
  Tides manual for details, I'm too lazy to copy them. The amplitude of the outputs is multiplied by the value of **Shift/Level** – 0.5. But the
  actual resulting amplitude seems to be different for each of the 3 modes AD, AR, LFO.
- _Different amplitudes_: All outputs emit the same signal, but with different amplitudes. If *Shift/Level* is set to 0.6, output 1 has the maximum
  amplitude. At 0.4 too, but inverted. At values ≥0.7, ≤0.3 and 0.5, the amplitude is 0. For output 2, the maximum amplitudes are at 0.7 and 0.3, and
  so on.
- _Different times_: changes the **Slope** setting so that it is different for each output. See the Tides manual for details.
- _Different frequencies_: the outputs 2 to 4 get frequencies different from output 1. See the Tides manual for details.


## Other CV sources
### LFO
Produces a periodic CV signal with a certain form. If **Unipolar** is set, the amplitude of the output signal goes from 0V to 5V∙**Level setting**, otherwise,
it has the range ±(5V∙**Level setting**).

There is an unlabeled slider (at least in Firmware 3.20). If you touch it, the Beebo crashes.

### Note sequencer
You can define the pitches for 16 steps which are emitted one after another as _CvPitch_. You are limited to 1 octave.

### Step sequencer
Like [Note sequencer](#note-sequencer), but with arbitrary CV values (0–5V) instead of notes.

### Pitch detect
Tries to guess the pitch of its audio input and emits it as _CvPitch_ and Midi Note and also a _CvGate_ while a note is playing.

Worked moderately well for me.

Strangely, the _CvPitch_ output doesn't seem follow the 1V/Oct convention, but more like 0.72V/Oct. This can be corrected by using [Pitch cal in](#pitch-cal-in) or [Pitch cal out](#pitch-cal-out) with Offset=0 and Scale=1.4.

The **Gate** output worked for me only if the **Silence Threshold** is quite high.

## Pitch calculations
These modules do things with _CvPitch_ signals.

### Pitch cal in
A _CvPitch_ in Beebo usually follows the convention that 0V is C4, 1V is C5 etc., also written as _1V/Oct_. If for some reason a module outputs a
_CvPitch_ with a different convention, this module can convert it back to 1V/Oct.

How to calibrate:
1. connect the module to be calibrated (the source module) to this one
2. activate the **Measure** button
3. make the source module play a C4
4. make the source module play a C6
5. deactivate the **Measure** button

From now on, the output of this module is 0V and 1V whenever the source module plays C4 and C5 etc., as it should be.

### Pitch cal out
Similar to [Pitch cal in](#pitch-cal-in), but manually. Basically, this module simply outputs a CV which is **Input** × **Scale** + **Offset**.

### Quantizer
Input is a _CvPitch_, output is the input, but quantized to the configured set of pitches.

The output **Changed** is probably supposed to output a _CvTrigger_ each time the pitch output changes, but in my experiments, most of the time it
didn't.

Also, the pitch quantizing seems to be buggy, the pitch output is jumpy and doesn't always monotonically increase with increasing input.

## CV Calculations
These modules do calculations with arbitrary CV signals.

### Sum
The output is **Input A** + 5V∙**Setting A** + **Input B** + 5V∙**Setting B**.

This module may be not necessary, because you can add two CV signals simply by connecting two cables to the same input.

### Difference
The output is **Input A** + 5V∙**Setting A** - (**Input B** + 5V∙**Setting B**).

### Attenuverter
Does more or less multiplication of its inputs. “Attenuverter” is a portmanteau of “attenuate” and “invert” and means that a signal is multiplied by a
factor in the range [-1, 1].

If there are two input signals, the result is **Input A** ∙ **Input B** / 5V, the settings are ignored

If there are no inputs, the output is **Setting A** ∙ **Setting B** ∙ 5V.

If there is an input signal A, the output is **Input A** ∙ **Setting B**, and vice versa.

### Max
The output is max(**Input A** + 5V∙**Setting A**, **Input B** + 5V∙**Setting B**).

### Rectify value
The output is the absolute value of the input: in go 3V, out go 3V. In go -2V, out go 2V.

One of the few modules without the slightest hidden gotcha.

## Audio effects
These modules do something with audio signals.

### VCA
Simply change the amplitude of the **Input Input** depending on the **Control Gain**, which can also be controlled externally.

Use cases:
- use an LFO to add tremolo to a note
- generally make the audio softer

### Mono EQ
A nice graphical equalizer with up to 6 bands. Each band can be deactivated or get an extra boost with the **Resonance** slider.

### Filter
A low pass filter. Can do self oscillation.

Both **Input FM** and **Input Exp FM** control the cutoff frequency. It seems that the values are simply multiplied.

I guess **Input resonance mod** simply controls the resonance, but is multiplied with the **Resonance gain** slider. In other words, the latter
controls the modulation depth of the former.

**Input gain** and **Output gain** both control the output volume, the difference is that only the latter affects also the sound caused by self
oscillation, so you can use both sliders to control its volume relative to the regular filtered audio.

### Diode ladder LPF
A basic low pass filter. The name hints at the filter of the classic Roland synths. **Q** is the resonance.

### Oog half filter
Yet another low pass filter. Apparently a simulation of the Moog half ladder filter.

### K org LPF
Yet another low pass filter with cutoff and resonance settings. I have the vague feeling the name hints at Korg synths.

### K org HPF
A high pass filter. Who would have thought?

### Filter Uberheim
A combined low pass, high pass, band pass and notch filter. The name obviously hints at Oberheim synths.

You can control the cutoff frequency and the resonance. There is an output for each of said filter types.

### Delay
A basic delay. The dry signal is not emitted, only the echos.

**Level** controls the volume of the wet signal relative to the dry signal. **Feedback** controls the dampening, that is, the volume of the echos
relative to the previous echo. Set it to 0 for (almost) only one echo and for 1 for infinite echos.

Setting the delay time is a bit confusing. It is shown in the text field **Milliseconds**. The value can be typed in directly, or be set with the
slider **BPM** (only visible if the radio button **Beats** is activated) or with the **Tempo input**. The **Time** factor is then multiplied with that
tempo, that is, BPM=60 and Time=1 result in a delay time of 1s, while BPM=60 and Time=2 cause the delay time to be 2s. Another way to set the factor
is to use the **Time signature dropdown** (only visible if the radio button **Beats** is activated). Changing this changes the value of the **Time**
slider to (time signature)·4. Practically speaking: if you use a foot switch module to tap to the song tempo which is 120BPM, and you tap on every 8th note, then
choose _1/8_ from the dropdown menu to get a delay time of 0.5s (which is the beat length of the song).
The option _1/8._ is equal to a **Time** factor of 0.75 and _phi_ to the reciprocal of the golden ratio, that is, 0.62. No idea what that's about.

**Tone** apparently controls an internal LPF.

**Warp** sets the position of the play head inside the delay buffer. The effect of that is, that with a value of -0.9, the first echo comes almost
immediately after the original dry signal, but the next echos still adhere to the normal delay time. But the more interesting purpose of this slider
is probably that _while_ the value is changed, the audio in the delay buffer is audibly stretched or compressed. It is a good idea to use an
[LFO](#lfo) to wiggle this value. However, the movement of the warp value (and therefore the audio twisting) is slowed down, so that fast jumps don't
cause ugly sound artifacts. The amount of slowing down is controlled by **Glide**, which sets the time in seconds when the audio twisting stops after
letting go of the warp slider.

### Bitcrushed Delay
Same as [Delay](#delay), but with an extra slider for bit reduction, which works the same as with [Bitcrusher](#bitcrusher).

I don't know what the advantages are for this module versus a combination of Delay and Bitcrusher.

### Basic Reverb
An algorithmic, stereo reverb.

### Quad IR Reverb
A convolution reverb. Load an IR to make it work.

An IR (impulse response) is the distribution of echos when a sound impulse is played in a certain hall. With that IR, this module makes each arbitrary
audio sound as if it was recorded in that hall. Hooray for mathematics!

### Chorus D
Adds a stereo chorus to a mono signal.

### Chorus D Ext
Like [Chorus D](#chorus-d), but without an internal LFO to make the chorus wiggle. You have to provide one.

### Chorus J
Apparently a simulation of the popular chorus of the Roland Juno.

### Flanger
Well, a flanger.

Waveshape seems to go from sinus to triangle shape.

### Phaser
A basic phaser.

### Phaser Ext
Like [Phaser](#phaser), but you have to provide a LFO yourself. Caution, if you feed in negative CV values, the module seems to crash, at least it
won't output anything anymore.

### Phaser Stereo Ext
Like [Phaser Ext](#phaser-ext), but with stereo output. Also, if this module crashes, only the left channel gets stuck.

### Doppler panner
Takes a mono or stereo signal and makes it sound like coming from a certain spot in the room. Has an internal LFO which makes the sound spin around the
listener's head. Also simulates the doppler effect when the spot is moving towards or away from the listener.

The left and right input channels are moved so that they are always at the opposite place.

**X Coordinate** (left/right) and **Y Coordinate** (near/far) control the place where the sound should come from.

**LFO Amplitude** and **LFO Frequency** control the amount and speed of the spinning. The frequency can go well into audio territory.

### Bitcrusher
Produces glitchy sounds by doing bit reduction.

### Granular
This is what _I think_ is happening here:
As the audio stream is passing through its play head as usual, a second play head is reading the audio signal “from the past” and _sometimes_ plays a
short snippet (the so called _grain_) of it back. Effects may be applied on this grain. Also, there is feedback involved by (I think) adding the grain
to the next grain.

The slider at the bottom right controls how often the second play head plays a grain. On the center position, it is played not at all. While turning the slider to the
left, a grain is played more and more often evenly distributed, until it is played virtually all the time, resulting in an almost normal sounding delay.
Turning it further to the left, multiple grains are produced which overlap. The right half of the slider works like the left half, only the grains are
randomly distributed instead of evenly.

Aside from that, a grain is also played when a _CvTrigger_ goes into the **Trigger** input.

The slider at the top right controls the envelope of the grain, resulting in a smoother or harsher overall texture. Fully set to the right, the grains
are somehow smeared.

The **Position** slider controls the distance between the two play heads, thereby setting the amount of delay from almost 0s to 1s, as far as I can tell.

The **Size** slider sets the length of the grains from 0.2s or so, where the input audio is still recognizable to very, very short which results in novel sounds.

The _Pitch_ slider controls a pitch change of the grain (also, it seems to influence the _position_ value). Together with the feedback control, this
results in funny ascending or decending glitchy sounds.

The _Blend_ slider simply controls the dry/wet ratio, that is, the relative volume of the two play heads.

The _Reverb_ control adds a (very strong) reverb, not only on the grain but also on the dry signal.

The _Spread_ slider controls how randomly the grains go to the left or right audio output.

The _Feedback_ slider controls how much a grain is damped before adding it to the next grain. Little dampening results in horrible feedback, so be
careful. Live-controlling this value using the hardware knob of the Beebo can be fun, though.

If the _Reverse_ knob is active, the grains are played in reverse.

Press and hold the _Freeze_ knob to “record” the audio input into a short buffer. After that, the grains are only generated from the audio in this buffer
instead of the input audio stream. The _Position_ slider now controls the position in the buffer used for the grains.

### Granular Looping
In the Beebo manual, this is called _Looping delay_.

Works similar to [Granular](#granular), but without the chopping of the audio into grains, that is, the complete audio is repeated.

**Tape length** sets the length of the buffer and therefore the length of the delay. Goes up to about 1s. Changing the value results in those typical funny
compressing and stretching sounds.

**Diffusion**: not sure what it does, but the heigher, the shorter the reverb tail. But there is more happening.

**Reverb**: adds a strong reverb

**Feedback**: like with [Granular](#granular), controls how much the current feedback buffer is dampened. A value < ~0.5 does dampening, thus the
feedback fades. With > ~0.5 the feedback gets stronger, so be careful. If **Pitch** is ≠0, there is more dampening happening.

**Filter** adds exactly this to the signal. On the left its a LPF, on the right a HPF.

**Reverse**: not sure what that does.

**Freeze**: works like with [Granular](#granular), but the recording buffer is rather short.

### Meta modulation
Blends two audio sources into one, how exactly depends on the configured mode.

This is based on [Warps](https://pichenettes.github.io/mutable-instruments-documentation/modules/warps/) by Mutable Instruments. However, the last 3
modes (Vocoder 1, Vocoder 2 and Freeze) don't work. If the mode slider is in the vincinity of those modes, the module simply doesn't output anything.
Beebo remains a mystery.

One of the two audio inputs is called **Carrier** and the other one **Modulator**, because that's how they work in some of the modes. Instead of an
audio input, the carrier can also be provided by an internal oscillator. It is activated by tapping two times on the little wave-like icon in the
upper left. Notice that the two rightmost buttons are mixed up: the button which says “sawtooth” produces a triangle wave and vice versa.

The **Level 1** slider on the second page of the module sets the volume of the carrier input or the frequency of the internal oscillator, if it is
used. **Level 2**, unsurprisingly, controls the volume of the modulator input. What **Timbre** does depends on the selected mode, but most of the time
it somehow controls the intensity of the effect.

What exactly are the ~~9~~6 modes doing? The first one, ”Crossfade” is easy, it's exactly that. The **Timbre** slider controls the balance between carrier
and modulator. For the other modes, consult the Warps manual.

### Pan
Allows to place an audio signal left or right.

Takes an audio signal and routes it to **Output Out L** or **Output Out R** according to a _CvSetting_.

### Pitch shift
Shifts the pitch of the input audio without stretching or compressing it. The audio (dry and wet) is audibly delayed.

### Harmonic Tremolo
In case you don't know what harmonic tremolo is: the audio signal is split into two audios which contain the low and the high frequencies,
respectively. This is done with a HPF and a LPF, obviously. Then, tremolo (that is, a periodically wobbling amplitude) is applied to both parts
individually, but phase-shifted, so that alternating the low and the high parts get louder.

**Crossover Freq** sets the frequency at which the audio is split.

### Harmonic Trem ext
Like [Harmonic Tremolo](#harmonic-tremolo), but you need to provide the LFO for the tremolo yourself.

### Auto swell
Softens the attack of an audio signal.

I think what happens is that when the amplitude of the input audio exceeds **Threshold**, it is first immediately softened. Then, it gets louder
by and by for **Uptime** seconds, until the original amplitude is reached. As long as the input holds this amplitude, from this point on, the audio is
not softened. Only if the input audio amplitude falls below **Threshold** for **Downtime** seconds, the process starts over and the next time the
audio exceeds the threshold, it is softened.

**Threshold** can also be set from the input.

### Freeze
„Freezes“ the input audio by repeating a short snippet (a grain) from it.

The grain is repeated as long as a _CvGate_ goes into **Input Freeze**.

### Matrix Mixer
4 audio streams can go in which can be routed to 3 outputs. **Left** is output 1, **Right** is output 2, **Send** is output 3.

### Mix VCA
I wasn't able to figure out what it does.

## Midi stuff
### CV to note
When a _CvGate_ goes in, a Midi note signal is send out. Its pitch is the one of the applied _CvPitch_ input or C4, if there is no pitch input.

### CV to Midi CC
Periodically sends CC Midi messages with a value corresponding to the input CV value. The CC number is configurable. Also the output Midi channel, but
there seems to be a bug, because what actually goes out has the channel number which is configured + 1.

**Resolution** refers to the value range, not the time.

### Midi CC
Converts a Midi CC message to a CV value.

As usual, **Minimum** and **Maximum** have to be multiplied by 5V to set the min and max voltage output. Also as usual, the values of the **CC Number** slider have to be rounded down to an integer number to get the configured CC number.

The output of the module is a constant voltage. Is is only updated when the input Midi CC message is changing.

If you want to use a CC value to control a slider in some module, you don't need this module, because there is an easier way: go to the module you
want to control, tap and hold the
three dots at the bottom of the screen and then tap the slider you want to control. In the menu which opens, tap the **Midi** button so that it starts
blinking and insert a Midi CC message into the Beebo, e.g. by turning a knob of a connected Midi controller.
This method has the advantage that the CC message also moves the slider, that means, the current value is immediately visible. A disadvantage is
that from the main screen you can't see if a slider is currently controlled by a CC value and which one.

### Midi CC to note
Turns a Midi CC message into a Midi Note-on message.

**Operation mode** rounded down to an integer is
- 0: the pitch of the output is the configured one, short duration, the velocity is set by the input CC value
- 1: the pitch is set by the CC. A CC value of 63 is C4, I think. Very short duration. The velocity is a constant of 2.5V.
- 2: like Operation Mode 0, but the pitch is a very low one
- 3: the pitch is very high and the velocity a constant of 1.5V

**Filter channel**: which Midi channels to listen to. 0 means all channels.

Looks like all non-CC messages (including Note-On) simply go through.

### Midi clock in
Turns a Midi tempo signal into Beebo-internal tempo signals.

Expects [Midi beat clock messages](https://en.wikipedia.org/wiki/MIDI_beat_clock) on the input, that is, a certain Midi message 24 per quarter note.

The tempo derived from the input is emitted as tempo signal and furthermore as CV signals:
- the **Is running** output emits a _CvGate_ which is open as long as there are Midi clock messages
- the **Start trigger** output emits a _CvTrigger_ when Midi clock messages start to arrive
- the **Clock pulse** output emits a _CvTrigger_ for each Midi clock message, that is, 24 triggers per quarter note. With the slider **Pulse divider**, you can reduce this number. A value of 24 results in one _CvTrigger_ per quarter note.

Related modules:
- [Midi clock out](#midi-clock-out) does the opposite

### Midi clock out
Emits [Midi beat clock messages](https://en.wikipedia.org/wiki/MIDI_beat_clock).

If a tempo signal is fed into the (invisible) tempo input, this tempo is regarded, otherwise the tempo of the **BPM** slider.

Related modules:
- [Midi clock in](#midi-clock-in) does the opposite

### Midi channel filter
It's exactly that. For each channel (which are nicely sorted alphabetically), you can decide if input messages on this channel should also appear in
the module's output  or be dismissed.

### Midi channel map
Changes the channel number of each Midi message. For each channel of an input message you can set the target channel number.

### Midi dup
Duplicates Midi messages from one channel to another.

### Midi keysplit
Splits a Midi keyboard so that one part goes to one Midi channel and one part to another.

Furthermore, both parts can be transposed independend of another.

### Midi choke filter
Out goes a Note-Off Midi signal for a configurable note whenever a Note-On for a note in a configurable range goes in. This is useful for making drum
beats a bit more realistic: when a closed hi-hat sound starts to play, any open hi-hat sound should stop immediately.

The key-off velocity of the output signal can be configured, but I don't know what the range of 0–2 is supposed to mean.

The setting **Filter channel** doesn't seem to have an effect, the channel of the output signal always seems to be the one of the input signal.

### Midi delay
Note on and off messages go in and come out, but delayed.

The delay time is derived from the **BPM** and **Delay beats 4/4** sliders. The latter is obviously the number of quarter beats by which the notes are
delayed. The tempo can also be fed into the module.

The **Randomize** slider controls how much the actual delay times are randomized. Use the two
physical knobs with this slider, because with touching you can only set it to 0 or 1.
Even with randomizing, the notes will come out in the same order as they were fed in.

### Midi chord
In goes one Midi note, out go multiple Midi notes which form a chord.

With the buttons, you configure which kinds of intervals are added to the input note, which is the root note of the chor. (**Bass** is an octave below
the root note, **Octave** one octave above.)
It then depends on the **Scale** slider whether the interval is a major or a minor one (for fourths and fifths: perfect or augmented/diminished), that is, the intervals are chosen so that they belong to the
configured scale.
The **Scale** value 0 means C major, 1 is C♯ major, 2 is D major and so on.

For example, if all interval buttons are activated and **Scale** is set to 0 (that is, C major), and a C4 note goes in, the resulting chord consist of
the notes C3 (“Bass”), C4 (the root), D4 (major 2nd), E4 (major 3rd), F4 (perfect 4th), G4 (perfect 5th), B4 (major 7th), C5 (“Octave”).
The input note B4 would result in: B3, B4, C5 (minor 2nd), D5 (minor 3rd), E5 (perfect 4th), F5 (diminished 5th), A5 (minor 7th), B5.
Another example: if you want to turn a C note into a C⁷ chord, activate the buttons _Prime_, _3rd_, _5th_ and _7th_ and set **Scale** to 5 (F major).

If the input note itself does not belong to the configured scale, it is emitted unchanged without any other notes.

With **Filter channel** you can specify on which Midi channel the module is listening. Messages on other channels simply go through unchanged. If 0,
it listens on all channels.

The function of the **Hold chord** switch was “When enabled, parameter changes apply to new chords only” in the
[apparent original code of this module](https://github.com/x42/midifilter.lv2/blob/master/filters/chord.c). I think here in Beebo, it has no effect.

### Midi Mono Legato
Holds a (single) note, until the same or another one is pressed.

In other words, this module swallows note-off Midi messages and instead sends one when a note-on of the same or a different note arrives.

Midi messages on channels other than the configured one go through unchanged, channel 0 means all channels are processed.

## Guitar & Bass
### Amp Bass
Simulates a bass amp. I guess the “SVT40” in the module description doesn't refer to this [Soviet semi-automatic battle rifle](https://en.wikipedia.org/wiki/SVT-40) but rather to some model of the Ampeg SVT series.

## Other modules
### CV Meter
Displays the value of its CV input. Useful if a patch doesn't work as expected and you want to see what's going on with all the CV values.

Displays the current value and the min and max values encountered. The latter two are only remembered as long as the **Reset** switch is turned off.

The slider has a range of -5V to 5V, while the displayed number is capped at -10V and 10V. No idea why, the other modules seem to handle voltages
above 10V just fine.

The CV output of the module equals its input.

### Clock divider
Takes _CvTriggers_ as input. Every _N_ input triggers, a trigger is emitted.

**N** can be an integer number from 1 to 24. Strangely, in this module you have to round the decimal number from the slider up instead of down to get
the resulting _N_.

### Loopler
Turns the Beebo into a looping pedal: record a sequence, overdub it, shorten or lengthen the loop etc.

It is advisable to assign the hardware knobs to actions of the loopler: tap and hold a command button and press the foot switch (not the other way
around as the manual suggests).
