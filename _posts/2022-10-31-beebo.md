---
layout: post
title:  "Notes about the Polyeffects Beebo"
date:   2022-10-31 20:10:00 +0100
---

The [Polyeffects Beebo](https://www.polyeffects.com/) is many things:
- a multi effects box for synthesizers
- an amp simulation and effects pedal for guitar and bass
- a polyphonic synthesizer
- a modular synthesizer in a box
- a loop station

One thing it is not:
- well documented

![The Polyeffects Beebo](/bilder/beebo.jpg)

That's why I write down here what I found out about its 100+ modules. May it be of use for future me and for other Beebo/Hector users. However,
note that I am not at all competent in what I do here. I won't reveal the inner workings of the ORG Reverb module for the simple reason that
I have no more than the most basic knowledge about effect units. Also, I can't say much about the guitar and bass amp and cab modules, because I have
neither guitar nor bass.

In my descriptions, I will also usually omit knobs or inputs which are super obvious or which can be easily googled, e.g. the parameters of common effect units.

This is also not meant to be an introduction to the Beebo. If you are new to this device, read the official manual first.

Anyway, let's start. My notes are valid for firmware version 327.
 
# General remarks
There are 4 different types of signals which can be routed between input, output and the individual modules like cables beween physical units:
- Audio: a single (i.e. mono) audio stream
- CV: control signals between modules
- Midi: a stream of Midi messages
- Tempo: tempo messages to synchronize modules

## More on CV signals
On physical modular synthesizers, CV (short for _control voltage_) signals are voltages in a defined range (e.g. -5V – +5V or 0V – 10V) and the
modules can use these voltages to communicate with each other. In the Beebo, being fully digital, these voltages are of course only virtual, but I'm
still going to use the unit symbol _V_.

The Beebo usually uses virtual voltages in the range -5V – +5V, but other values are possible.

The CV signals serve a lot of different purposes: they can activate a module, set a parameter of a module, define the amplitude of a sound over
time (i.e. the envelope) and other things. So it makes sense to further divide the CV signals into subtypes. I'm going to prefix the subtype names
with _Cv_, to make it clear if I'm talking about e.g. triggers in a general sense or about a CV signal which is acting as a trigger.

- CvTrigger
    (Bild)
    A signal at level 0V most of the time with a very short spike to 5V and back. It is used to, well, trigger some behavior in a module. Modules which
    receive a _CvTrigger_ (at least the ones I tested) actually seem to to react to all CV signals which get higher than 2V.

- CvGate
    (Bild)
    A signal at level 0V with a sudden flank up to 5V and back to 0V after some time. Used to activate and then deactivate some behavior in a module. As
    with _CvTriggers_, on a receiving module, all signals which cross the boundary of 2V seem to work as _CvGate_.

- CvEnvelope
    (Bild)

- CvPitch
    (Bild)
    Represents a constant or changing pitch over time.
    A signal at level 0V usually represents C4 (the middle C), 1V is C5, 2V is C6, -1V is C3, 0.08333V is C♯4 etc.

- CvSetting
    Is used to set settings of modules which may vary over time, also known as modulation.

    Most of the modules have sliders and knobs to configure them. Some of these settings can be controlled not only by manually slide the sliders but also
    using a signal. It seems that the range for the signal is always 0V to 5V (for monomodal settings) or -5V to 5V (for bimodal settings), no matter
    which range is displayed at the slider. For example: if a slider has a displayed range from 0 to 1 (the most frequent case), feed a value of 4V into
    the module to set it to a value of 0.8. That's why there is sometimes a factor of 5 which crops up in my descriptions of the modules.

    Keep in mind that when a slider is controlled by a _CvSettings_ input, the displayed value of the slider is ignored. It is also not visible which
    slider is currently externally controlled.


This is my own made-up distinction of CV subtypes. It is only a logical distinction, not a technical one. Nobody stops you from feeding the triggers
coming from the foot pedal module into the cv/oct input of the Macro Osc module, even though it doesn't make any sense. In my description of the
modules, I'm going to state which type of CV signal is meant to be used, but feel free to disregard it. Maybe you come up with some cool stuff.

## A word about Midi
If you have trouble connecting other gear to the Beebo via Midi, keep in mind that there are two kinds of frequently used Midi TRS connectors, which
are visually indistinguishable. They are, originally enough, called type A and type B. Different batches of the Beebo require different types of these
connectors.
According to the [FAQ](https://www.polyeffects.com/faqs), the following types are used (you can find the serial number on a sticker on the back of the Beebo):
- Pink case with serial number ≤ 474 or blue case with serial number ≤ 337: type B for in and out
- Pink case with serial number 475–876 or blue case with serial number 338–936: type A for input, type B for output
- Pink case with serial number ≥ 877 or blue case with serial number ≥ 937: type A for in and out

## Global settings
In the global settings menu, there is a setting **Midi channel**. I don't know what it does, because AFAICS all modules either have individual
settings for their input or output channel, or they listen to all channels, or their output channel depends on the input.

If **D is Tuner** is switched on, the foot switch D (that is, A and B at the same time) immediately switches to a patch containing the Guitar Tuner module.

# The modules
## Audio sources
These modules produce audio triggered by _CvTriggers_ or _CvGates_.

### Macro OSC
**Warning**: the audio output of this module is rather loud when using headphones. Consider routing the audio through a [VCA module](#vca) with gain
around 0.5.

A monophonic instrument and drum synthesizer with 16 different synthesis engines, or 32 if you want, because each one has two variants, which
emit their audios on the **Out** and **Aux** outputs, respectively.

The first 11 (melody-like) engines are triggered in a different way than the last 5 (which are more suitable for drums):

For the first 11 engines, there are multiple ways:
- feed a _CvEnvelope_ (or a _CvGate_ which is only a special case of an envelope) into **Input Level**
- feed a _CvTrigger_ into **Input Trigger** while there is no connection to **Input Level**: a sound is played with an AD envelope (which really looks
  like a reverse sawtooth, that is, A=0). This envelope can control no less than 5 values: volume, cutoff of an internal LPF, frequency, morph and
  timbre. The sliders **Frequency Mod**, **Morph Mod** and **Timbre Mod** control the amount of that modulation. **LPG Color** controls the amount of 
  volume and filter modulation: left means only the filter, right means only volume. **LPG Decay** controls the decay of the envelope.
- if there are both an _CvEnvelope_ at **Input Level** and a _CvTrigger_ at **Input Trigger**, the sound caused by the former is temporarily overlaid
  with the latter. But in this case, the AD envelope doesn't modulate frequency, morph and timbre.

For the last 5 engines, it’s a bit simpler:
- feed a _CvTrigger_ into **Input Trigger* to trigger the drum sound. The **LPG Color** and **LPG Decay** sliders have no effect, because the engines
  all have a decay slider in the tab with their individual settings.
- insert a _CvTrigger_ into **Input Trigger** and a _CvGate_ into **Input Level** at the same time to produce an acceted drum sound
- insert a _CvEnvelope_ into **Input Level** while there is no connection to **Input Trigger**. This produces a sustained drum sound, which 
  itself is not that useful, but you can use that to have full control over the envelope.

To control the pitch of the sound, use either a _CvPitch_ with **Input V/Oct** or **Input Frequency**. For the latter, you have to set the slider **Frequency Mod** to
a value ≠ 0. Or use both, e.g. **Input V/Oct** to set the note and and LFO to **Input Frequency** to produce a vibrato.

The values of the sliders in the **Modulation** submenu are multiplied with the corresponding input signals. So, to modulate e.g. the timbre value,
set **Setting Timbre Mod** to ≠ 0 and feed an LFO into **Input Timbre Cv**.

In the **Tone** submenu, the sound can be adjusted. The 3 sliders behave different for each of the synth engines. **Timbre** usually
changes the sound from dark and dirty to bright and clean. **Harmonics** usually introduces dissonances.
I'm not going to describe the settings for the 16 synth engines. Firstly because they are relatively well documented in the [manual of the Plaits module](https://pichenettes.github.io/mutable-instruments-documentation/modules/plaits/manual/)
and secondly because I got tired of the constant freezes and bugs when playing around with this bugger.

## Gate or trigger sources
### Foot Switch A to E
Foot switch D is triggered if A and B are pressed at the same time. (If D is not assigned, both A and B are triggered in this case.)
E is the same with B and C.

Outputs of this module are
- a _CvGate_ with definable levels for the closed and the open phases. Depending on the **Is Latching** setting, the gate is open as long as the
  foot switch is pressed, or it switches between the two levels with each press.
- a tempo, either the configured one or the one determined by repeatedly pressing the foot switch. Can go from 35 to 350 BPM.

If you want to switch a complete module on and off using a foot switch, you don't need a foot switch module. Simply tap and hold a module and press the
desired foot switch.

### Onset Detect
Produces a _CvGate_ when there is a sudden amplitude raise in the audio input, e.g. a played note.

This module is not simply triggered when the input audio exceeds a certain threshold. Instead, **Onset Threshold** refers to the attack time of the
input audio: the higher the value, the faster the attack needs to be to trigger this module. At the lowest value, the attack still needs to be faster
than ~300ms.

### Cv to Trigger
Produces a _CvTrigger_, when the (arbitrary) CV input exceeds 0.4V. The input must fall to a lower level than that before a trigger can be produced
again.

### Drum patterns
Produces three periodic _CvTriggers_, which are meant to trigger a bass drum, a snare and a hihat, respectively. Together, they result in a
most of the time well-sounding drum pattern.

Additionally, there are three outputs which send out _CvTriggers_ if the corresponding drum beat may be accentuated.

The sliders _Bass Drum Density_, _Snare Density_ and _Hihat Density_ control **how often** the respective sound appears from _not at all_ to _on every beat_.

The sliders _Map X_ and _Map Y_ control **when** the three sounds appear. The pattern is deterministic, but not really predictable. Slowly changing
the X and Y values produces smooth transitions between patterns.

The _Chaos_ slider controls the amout of random variation of the _Density_ controls.

A _CvTrigger_ in the **Reset** input resets the pattern, so that it starts on the first beat again.

### Euclidean
The output is up to 4 tracks of _CvTriggers_ which can be used to create a drum pattern.

Each of the 4 tracks has an adjustable number (0–32) of steps. Of these, an adjustable number is _active_, all others are _passive_. Every time a
trigger goes into this module, each track jumps to its next step. If this next step is active, a _CvTrigger_ is emitted (to generate a drum sound.)

You can't precisely configure which steps of a track are active. All you can configure is the number of active steps and an offset. Starting from the
step set by offset, the active steps are evenly (as far as possible) distributed on the track.

If a track arrives on its first step again, a trigger on the corresponding **Is The One** output is emitted, no matter if the first step is active or not.

Use cases:
- if the lengths of the tracks are different (especially if they are coprime), interesting polyrhythms may emerge
- this pattern on the other hand produces a simple house beat: (Bild)

### Chaos controler
Outputs random, but controlled gates plus voltage levels for each gate.
It is based on [Marbles by Mutable Instruments](https://pichenettes.github.io/mutable-instruments-documentation/modules/marbles/manual/).

The “main” outputs are **T2 Output**, which emits a stream of _CvGates_, and **X2 Output**, which emits a voltage which is constant while the gate in
**T2** is open.
The outputs **T1 Output**/**X1 Output** and **T3 Output**/**X3 Output** work similar. Their appearances and values are somehow dependend of **T2**/**X2**.
The output **Y Output** is an additional random CV signal, which is independent (except for its tempo) of the **T** and **X** outputs.

In the page **Gate generator**, you control **T1** to **T3**, that is, _when_ the gates appear and their pulse width:
The gates of **T2** always have a 50% pulse width and go out evenly with the tempo set by the slider **T clock BPM** and its multiplier above.
Alternatively, new gates can be triggered by a _CvTrigger_ into **Input T clock trigger**. In this case, the slider **T clock BPM** has a different
functionality and acts as a random multiplier: values > 120 BPM will sometimes cause 2 or 3 gates per step, values < 120 BPM will cause a gate every 2
or 3 steps.

The slider **Jitter** adds randomness to the times of the gates. Also, it seems to randomly modify the pulse widths of **T1** and **T3**.

But generally, **T1** and **T3** are always very narrow pulses. Their times depend on the **Bias** slider and the configured mode:
- **Coin toss**: with each gate in **T2**, one gate comes out of either **T1** or **T3**, but not both. The heigher **Bias** is, the more likely it is
  that **T3** is the winner.
- **Random ratio**: when **Bias** is 0.5, all gates come out of **T1**, **T2** and **T3** at the same time. If it is less than 0.5, the gates of
  **T3** sometimes come out only every 2, 3, 4 or 8 steps of **T2**. If it is higher, **T3** may emit 2, 3, 4 or 8 gates with each step of **T2**.
  **T1** works vice versa.
- **Percussive triggers**: the gates of **T1** and **T3** come out in such a way that they form a drum pattern with kick and snare, respectively.
  **T2** could trigger hi-hats. A **Bias** value of 0.5 makes a regular boom-chuck pattern, other values cause more kick or snare triggers (but in a
  random way).

The page **X voltage** controls the levels which come out of **X1** to **X3**.

The 3 buttons under “Output voltage range” set the range of the voltages to 0–2V, 0–5V or -5–5V.

The slider **X spread** sets the probability distribution of the values from infinitesimally narrow bell curve (at 0.0) to bell curve to uniform
distribution (at ~0.7) to bathub shaped distribution.
The slider **X distribution bias** sets the position of the distribution curve in the range.

The slider under **Smoothness** controls how the X values are changed: at the center position, a new value is emitted with each step of **T2**. Left of
the center, the values glide smoothly between their values. Right of the center causes hard transitions, but the values are quanzited so that they, when
interpreted as _CvPitch_, belong to the scale set in the page **Steps quantizer**. The further right, the less different X values there will be.

The outputs **X1**, **X2** and **X3** work independently of another.
The 3 buttons under **Output controls** introduce even more diversity between these 3 outputs:
- the button in the middle makes it so that only **X2** follows the settings of 3 sliders in this page, while **X1** and **X3** will behave as if the 3 sliders are mirrored.
- the right button makes **X3** follow the settings and **X1** the mirrored settings. **X2** takes the middle positions of the 3 sliders. I think the
  icons of the middle and the right buttons should be swapped.
- the left button makes all outputs follow the sliders

As if that wasn't enough randomization, the whole behaviour of the **X**es is different if the slider **External control** is switched on. In this
case,**X2** take the value which is present at the **X spread** input at the time the gate starts. The slider **X spread** moves these values
(that is, adds a value) and **X bias** changes the value range (that is, multiplies it with a factor). This is a bit odd, it should be the other way
around. **X1** and **X3** have the same values as **X2** most of the time, but every now and then keep their values for several steps. That is, when
there is not input into **X clock**. If there is, other things happen which I don't understand.

In the section **Deja vu**, you can add some order to the chaos by making the patterns of the **T** and **X** outputs (partly) repeat.
With the two buttons **t** and **X**, you can set if you want to have repetitions in the **T**s or **X**es or both.
The slider **Deja vu length** controls the length of a repeated pattern from 1 step of **T2** to 2 steps (at ~0.2) to 8 (around ~0.8) to 16 (at 1.0).
The slider **Deja vu probability** (or **Deja vu Input**) controls how identical the repetitions will be: at 0.5, the pattern is repeated unchanged. The the further left,
the more random changes are applied. At values > 0.5, only values from within the remembered patterns are used, and the further right, the more
randomly it will jump inside the pattern buffer.

The page **Y voltage** controls the **Y** output. **Rate** is the tempo which goes from the rate of **T2** to the rate of **T2** divided by 64.
**Spread** sets the rage of **Y** values and goes from 0 to -5–5V. The icons of the **Bias** slider have the wrong order.

## Envelope sources
Modules which produce _CvEnvelopes_, triggered by _CvTriggers_, _CvGates_ or Audio.

### AD Envelope
A _CvTrigger_ on either input produces on the output a curve which looks like a triangle: linear rise from 0V to 5V for the time set with **Attack Time**, followed by a linear drop back to 0V for the time set with **Decay Time**.

The two inputs **Gate** and **Trigger** seem to behave identically, if I'm not mistaking.

If the input is a _CvGate_, it gets more complicated:
- first a logarithmic raise to 5V (logarithmic means a steep initial curve which gets flatter and flatter so that 5V are theoretically never reached)
- when the gate closes, the attack(!) phase starts by going linearly from the current value up to the final value of 5V in the time set under **Attack Time**
- afterwards, the decay phase starts by going down to 0V as above

### AD Env Level
Similar to [AD Envelope](#ad-envelope), this produces an envelope which may look like a triangle, but instead of going 0V → 5V → 0V, the three levels can be configured.

The two inputs **Gate** and **Trigger** seem to behave identically, if I'm not mistaking.

If the input is a _CvTrigger_, the output voltage jumps to **Initial Level**·5V, then rises (or drops) linearly to **Attack to Level**·5V in **Attack Time** seconds, then drops (or rises) to **Decay to Level**·5V in **Decay Time** seconds.

If the input is a _CvGate_, the output stays at **Initial Level**·5V as long as the gate is open, before rising and dropping.

**Input Reset Level** takes a _CvTrigger_ and makes the output jump to **Initial Level**·5V. At least if the envelope is in its “resting phase”. If this input is triggered while the envelope is in its rising or dropping phase, weird things happen. Not sure if this is a bug or intentional.

### ADSR
Produces your ordinary ADSR envelope out of a _CvGate_.

The control **Trigger Threshold** adjusts how high the input CV must be to count as an open gate.

### DAHDSR
Like [ADSR](#adsr), but with an additional delay phase (a certain time from the gate start until the attack phase starts) and an additional hold phase
(a certain time between the attack and the decay phases).

### Env Follower
Produces an ASD curve (looks like a trapezoid), but not triggered by a CV event, but whenever the input audio level exceeds a threshold.

If **Invert** is activated, the output is 5V - (the normal value), or in other words, the output looks like a bathtub.

### Looping Envelope
Can produce either an AD envelope, an AR envelope or function as an LFO. Can do more crazy transitions than linear ones.

The input **Trigger** wants a _CvTrigger_ if in AD or LFO mode and a _CvGate_ if in AR mode. In LFO mode, the input trigger makes the LFO start again
with an upwards slide.

The controls under **Mod** are multiplied with their respective inputs.

## Other CV sources
### LFO
Produces a periodic CV signal with a certain form. If **Unipolar** is set, the amplitude of the output signal goes from 0V to 5V∙**Level setting**, otherwise,
it has the range ±(5V∙**Level setting**).

There is an unlabeled slider (at least in Firmware 3.20). If you touch it, the Beebo crashes.

### Note sequencer
You can define the pitches for 16 steps which are emitted one after another as _CvPitch_. You are limited to 1 octave.

### Step sequencer
Like [Note sequencer](#note-sequencer), but with arbitrary CV values (0–5V) instead of notes.

### Pitch detect
Tries to guess the pitch of its audio input and emits it as _CvPitch_ and Midi Note and also a _CvGate_ while a note is playing.

Worked moderately well for me.

Strangely, the _CvPitch_ output doesn't seem follow the 1V/Oct convention, but more like 0.72V/Oct. This can be corrected by using [Pitch cal in](#pitch-cal-in) or [Pitch cal out](#pitch-cal-out) with Offset=0 and Scale=1.4.

The **Gate** output worked for me only if the **Silence Threshold** is quite high.

## Pitch calculations
These modules do things with _CvPitch_ signals.

### Pitch cal in
A _CvPitch_ in Beebo usually follows the convention that 0V is C4, 1V is C5 etc., also written as _1V/Oct_. If for some reason a module outputs a
_CvPitch_ with a different convention, this module can convert it back to 1V/Oct.

How to calibrate:
1. connect the module to be calibrated (the source module) to this one
2. activate the **Measure** button
3. make the source module play a C4
4. make the source module play a C6
5. deactivate the **Measure** button

From now on, the output of this module is 0V and 1V whenever the source module plays C4 and C5 etc., as it should be.

### Pitch cal out
Similar to [Pitch cal in](#pitch-cal-in), but manually. Basically, this module simply outputs a CV which is **Input** × **Scale** + **Offset**.

### Quantizer
Input is a _CvPitch_, output is the input, but quantized to the configured set of pitches.

The output **Changed** is probably supposed to output a _CvTrigger_ each time the pitch output changes, but in my experiments, most of the time it
didn't.

Also, the pitch quantizing seems to be buggy, the pitch output is jumpy and doesn't always monotonically increase with increasing input.

## CV Calculations
These modules do calculations with arbitrary CV signals.

### Sum
The output is **Input A** + 5V∙**Setting A** + **Input B** + 5V∙**Setting B**.

This module may be not necessary, because you can add two CV signals simply by connecting two cables to the same input.

### Difference
The output is **Input A** + 5V∙**Setting A** - (**Input B** + 5V∙**Setting B**).

### Attenuverter
Does more or less multiplication of its inputs. “Attenuverter” is a portmanteau of “attenuate” and “invert” and means that a signal is multiplied by a
factor in the range [-1, 1].

If there are two input signals, the result is **Input A** ∙ **Input B** / 5V, the settings are ignored

If there are no inputs, the output is **Setting A** ∙ **Setting B** ∙ 5V.

If there is an input signal A, the output is **Input A** ∙ **Setting B**, and vice versa.

### Max
The output is max(**Input A** + 5V∙**Setting A**, **Input B** + 5V∙**Setting B**).

### Rectify value
The output is the absolute value of the input: in go 3V, out go 3V. In go -2V, out go 2V.

One of the few modules without the slightest hidden gotcha.

## Audio effects
These modules do something with audio signals.

### VCA
Simply change the amplitude of the **Input Input** depending on the **Control Gain**, which can also be controlled externally.

Use cases:
- use an LFO to add tremolo to a note
- generally make the audio softer

### Diode ladder LPF
A basic low pass filter. The name hints at the filter of the classic Roland synths. **Q** is the resonance.

### Filter Uberheim
A combined low pass, high pass, band pass and notch filter. The name obviously hints at Oberheim synths.

You can control the cutoff frequency and the resonance. There is an output for each of said filter types.

### Oog half filter
Yet another low pass filter. Apparently a simulation of the Moog half ladder filter.

### Delay
This is again very confusing. The delay time is somehow determined by the settings **Time**, **BPM** and the input field on the right, where you can
either input Milliseconds or set a beat fraction. Neither of these times are the actual delay time. These values are dependend of each other, namely
Time = BPM/60 * Milliseconds.

**Tone** apparently controls an internal LPF.

Changing **Warp** changes the pitch of the delayed audio. Whan you let go of the slider, the pitch goes back to its original pitch. The duration for
that is controled with **Glide**.

### Bitcrushed Delay
Same as [Delay](#delay), but with an extra slider for bit reduction, which works the same as with [Bitcrusher](#bitcrusher).

I don't know what the advantages are for this module versus a combination of Delay and Bitcrusher.

### Basic Reverb
An algorithmic, stereo reverb.

### Quad IR Reverb
A convolution reverb. Load an IR to make it work.

An IR (impulse response) is the distribution of echos when a sound impulse is played in a certain hall. With that IR, this module makes each arbitrary
audio sound as if it was recorded in that hall. Hooray for mathematics!

### Chorus D
Adds a stereo chorus to a mono signal.

### Chorus D Ext
Like [Chorus D](#chorus-d), but without an internal LFO to make the chorus wiggle. You have to provide one.

### Chorus J
Apparently a simulation of the popular chorus of the Roland Juno.

### Phaser
A basic phaser.

### Phaser Ext
Like [Phaser](#phaser), but you have to provide a LFO yourself. Caution, if you feed in negative CV values, the module seems to crash, at least it
won't output anything anymore.

### Phaser Stereo Ext
Like [Phaser Ext](#phaser-ext), but with stereo output. Also, if this module crashes, only the left channel gets stuck.

### Doppler panner
Takes a stereo signal and makes it sound like coming from a certain spot in the room. Has an internal LFO which makes the sound spin around the
listener's head. Also simulates the doppler effect when the spot is moving towards or away from the listener.

The left and right input channels are moved so that they are always at the opposite place.

**X Coordinate** and **Y Coordinate** control the place where the sound should come from.

**LFO Amplitude** and **LFO Frequency** control the amount and speed of the spinning.

### Bitcrusher
Produces glitchy sounds by doing bit reduction.

### Granular
This is what _I think_ is happening here:
As the audio stream is passing through its play head as usual, a second play head is reading the audio signal “from the past” and _sometimes_ plays a
short snippet (the so called _grain_) of it back. Effects may be applied on this grain. Also, there is feedback involved by (I think) adding the grain
to the next grain.

The slider at the bottom right controls how often the second play head plays a grain. On the center position, it is played not at all. While turning the slider to the
left, a grain is played more and more often evenly distributed, until it is played virtually all the time, resulting in an almost normal sounding delay.
Turning it further to the left, multiple grains are produced which overlap. The right half of the slider works like the left half, only the grains are
randomly distributed instead of evenly.

Aside from that, a grain is also played when a _CvTrigger_ goes into the **Trigger** input.

The slider at the top right controls the envelope of the grain, resulting in a smoother or harsher overall texture. Fully set to the right, the grains
are somehow smeared.

The **Position** slider controls the distance between the two play heads, thereby setting the amount of delay from almost 0s to 1s, as far as I can tell.

The **Size** slider sets the length of the grains from 0.2s or so, where the input audio is still recognizable to very, very short which results in novel sounds.

The _Pitch_ slider controls a pitch change of the grain (also, it seems to influence the _position_ value). Together with the feedback control, this
results in funny ascending or decending glitchy sounds.

The _Blend_ slider simply controls the dry/wet ratio, that is, the relative volume of the two play heads.

The _Reverb_ control adds a (very strong) reverb, not only on the grain but also on the dry signal.

The _Spread_ slider controls how randomly the grains go to the left or right audio output.

The _Feedback_ slider controls how much a grain is damped before adding it to the next grain. Little dampening results in horrible feedback, so be
careful. Live-controlling this value using the hardware knob of the Beebo can be fun, though.

If the _Reverse_ knob is active, the grains are played in reverse.

Press and hold the _Freeze_ knob to “record” the audio input into a short buffer. After that, the grains are only generated from the audio in this buffer
instead of the input audio stream. The _Position_ slider now controls the position in the buffer used for the grains.

### Looping Delay
Works similar to [Granular](#granular), but without the chopping of the audio into grains, that is, the complete audio is repeated.

**Tape length** sets the length of the buffer and therefore the length of the delay. Goes up to about 1s. Changing the value results in those typical funny
compressing and stretching sounds.

**Diffusion**: not sure what it does, but the heigher, the shorter the reverb tail. But there is more happening.

**Reverb**: adds a strong reverb

**Feedback**: like with [Granular](#granular), controls how much the current feedback buffer is dampened. A value <0.5 does dampening, thus the
feedback fades. With >0.5 the feedback gets stronger, so be careful. If **Pitch** is ≠0, there is more dampening happening.

**Filter** adds exactly this to the signal. On the left its a LPF, on the right a HPF.

**Reverse**: not sure what that does.

**Freeze**: works like with [Granular](#granular), but the recording buffer is rather short.

### Pan
Allows to place an audio signal left or right.

Takes an audio signal and routes it to **Output Out L** or **Output Out R** according to a _CvSetting_.

### Pitch shift
Shifts the pitch of the input audio without stretching or compressing it. The audio (dry and wet) is audibly delayed.

### Harmonic Tremolo
In case you don't know what harmonic tremolo is: the audio signal is split into two audios which contain the low and the high frequencies,
respectively. This is done with a HPF and a LPF, obviously. Then, tremolo (that is, a periodically wobbling amplitude) is applied to both parts
individually, but phase-shifted, so that alternating the low and the high parts get louder.

**Crossover Freq** sets the frequency at which the audio is split.

### Harmonic Trem ext
Like [Harmonic Tremolo](#harmonic-tremolo), but you need to provide the LFO for the tremolo yourself.

### Auto swell
Softens the attack of an audio signal.

I think what happens is that when the amplitude of the input audio exceeds **Threshold**, it is first immediately softened. Then, it gets louder
by and by for **Uptime** seconds, until the original amplitude is reached. As long as the input holds this amplitude, from this point on, the audio is
not softened. Only if the input audio amplitude falls below **Threshold** for **Downtime** seconds, the process starts over and the next time the
audio exceeds the threshold, it is softened.

**Threshold** can also be set from the input.

### Freeze
„Freezes“ the input audio by repeating a short snippet (a grain) from it.

The grain is repeated as long as a _CvGate_ goes into **Input Freeze**.

### Matrix Mixer
4 audio streams can go in which can be routed to 3 outputs. **Left** is output 1, **Right** is output 2, **Send** is output 3.

### Mix VCA
I wasn't able to figure out what it does.

## Midi stuff
### CV to note
When a _CvGate_ goes in, a Midi note signal is send out. Its pitch is the one of the applied _CvPitch_ input or C4, if there is no pitch input.

### CV to Midi CC
Periodically sends CC Midi messages with a value corresponding to the input CV value. The CC number is configurable. Also the output Midi channel, but
there seems to be a bug, because what actually goes out has the channel number which is configured + 1.

**Resolution** refers to the value range, not the time.

### Midi CC
Converts a Midi CC message to a CV value.

As usual, **Minimum** and **Maximum** have to be multiplied by 5V to set the min and max voltage output. Also as usual, the values of the **CC Number** slider have to be rounded down to an integer number to get the configured CC number.

The output of the module is a constant voltage. Is is only updated when the input Midi CC message is changing.

If you want to use a CC value to control a slider in a different module, you don't need this module, because there is an easier way: tap and hold the
slider you want to control and tap the button with the three dots at the bottom of the screen. In the menu which opens, ...
This method has the advantage that the CC message also moves the slider, that means, the current value is immediately visible. A disadvantage might be
that from the main screen you can't see if a slider is currently controlled by a CC value and which one.

### Midi CC to note
Turns a Midi CC message into a Midi Note-on message.

**Operation mode** rounded down to an integer is
- 0: the pitch of the output is the configured one, short duration, the velocity is set by the input CC value
- 1: the pitch is set by the CC. A CC value of 63 is C4, I think. Very short duration. The velocity is a constant of 2.5V.
- 2: like Operation Mode 0, but the pitch is a very low one
- 3: the pitch is very high and the velocity a constant of 1.5V

**Filter channel**: which Midi channels to listen to. 0 means all channels.

Looks like all non-CC messages (including Note-On) simply go through.

### Midi channel filter
It's exactly that. For each channel (which are nicely sorted alphabetically), you can decide if input messages on this channel should also go out or
dismissed.

### Midi choke filter
Out goes a Note-Off Midi signal for a configurable note whenever a Note-On for a note in a configurable range goes in. This is useful for making drum
beats a bit more realistic: when a closed hi-hat sound starts to play, any open hi-hat sound should stop immediately.

The key-off velocity of the output signal can be configured, but I don't know what the range of 0–2 is supposed to mean.

The setting **Filter channel** doesn't seem to have an effect, the channel of the output signal always seems to be the one of the input signal.

## Guitar & Bass
### Amp Bass
Simulates a bass amp. I guess the “SVT40” in the module description doesn't refer to the [Soviet semi-automatic battle rifle](https://en.wikipedia.org/wiki/SVT-40) but rather to some model of the Ampeg SVT series.

## Other modules
### CV Meter
Displays the value of its CV input. Useful if a patch doesn't work as expected and you want to see what's going on with all the CV values.

Displays the current value and the min and max values encountered. The latter two are only remembered as long as the **Reset** switch is turned off.

The CV output of the module equals its input.

### Clock divider
Takes _CvTriggers_ as input. Every _N_ input triggers, a trigger is emitted.

**N** can be an integer number from 1 to 24. Strangely, in this module you have to round the decimal number from the slider up instead of down to get
the resulting _N_.

### Loopler
Turns the Beebo into a looping pedal: record a sequence, overdub it, shorten or lengthen the loop etc.

It is advisable to assign the hardware knobs to actions of the loopler: tap and hold a command button and press the foot switch (not the other way
around as the manual suggests).
